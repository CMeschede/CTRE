#' Create a CTRM object
#'
#' The constructor for the class \code{'mrp'} (max-renewal process).
#'
#' @return An object of class 'mrp' (max-renewal process).
#' @param TT a vector of event times.
#' @param JJ a vector of event magnitudes, same length as \code{TT}.
#' @examples
#' times <- cumsum(MittagLeffleR::rml(n = 1000, tail = 0.8, scale = 5))
#' magnitudes <- rexp(n = 1000)
#' mrp <- new_mrp(times, magnitudes)
#' @export
#' @seealso \link{plot.mrp}


new_mrp <- function(x) {
  if ("zoo" %in% class(x)) {
    TT <- zoo::index(x)
    if (!all(sort(TT) == TT))
      stop("Strange... time indices not sorted. Please file a bug.")
    JJ <- zoo::coredata(x)
    if (!is.vector(JJ))
      stop("Magnitudes must be a vector.")
  } else if (any(class(x) == "data.frame")) {
    TT <- x[[1]]
    if (!any(class(TT) %in% c("numeric", "Date", "integer", "POSIXct")))
      stop("First column must be of class numeric or Date.")
    JJ <- x[[2]]
    if (length(TT) != length(JJ))
      stop("Times and magnitudes must have equal length.")
    # order the pairs (time, magnitude)
    JJ <- JJ[order(TT)]
    TT <- TT[order(TT)]
  } else
    stop("x must be of class zoo or a data frame with two columns.")

  if (!(class(JJ) %in% c("numeric", "integer")))
    stop("Magnitudes must be numeric.")

  n <- length(TT)
  if (n < 5)
    stop("need at least 5 observations")

  idxJ <- order(JJ, decreasing = TRUE)
  MLestimates <- NULL
  f <- function(what, ...) {
    # compute Mittag-Leffler estimates, but only once
    if (is.null(MLestimates) &&
        (what == "MLtail" || what == "MLscale")) {
      message("Computing Mittag-Leffler estimates for all thresholds.")
      MLestimates <<- ML_estimates(ks = 5:n)
    }

    switch (
      what,
      data = plot_data(...),
      diagnostics = plot_diagnostics(...),
      MLtail = plot_MLtail(...),
      MLscale = plot_MLscale(...),
      GPthreshold = plot_GPthreshold(...),
      thin    = apply_threshold(...),
      MLqq = plot_MLqq(...),
      hillPlot = hillPlot(...),
      iidTest = cross_cor(),
      is.uncoupled = empiCopula(),
      getTimes = getTimes(),
      getMags = getMags(),
      stop("unknown plot type: ", what)
    )
  }

  # "methods" for the mrp "object"
  plot_data <- function(p = 0.05) {
    plot(
      TT,
      JJ,
      type = 'h',
      col = 'gray',
      ylim = c(0, max(JJ)),
      xlab = "times",
      ylab = "magnitudes"
    )
    k <- ceiling(n * p)
    idxJ <- order(JJ, decreasing = TRUE)
    ell <- JJ[idxJ][k]
    ell <- ifelse(is.na(ell), 0, ell)
    abline(h = ell, lty = 2)
    ii <- which(JJ > ell)
    n <- length(ii)
    points(TT[ii],
           rep(0, n),
           col = 4,
           pch = 3,
           lwd = 3)
    for (i in ii) {
      xx = c(TT[i], TT[i])
      yy = c(ell, JJ[i])
      lines(xx, yy, col = 2)
    }
  }

  ML_estimates <- function(ks = 5:n) {
    plyr::ldply(.data = ks, function(k) {
      WW <- diff(sort(as.vector(TT[idxJ[1:k]])))
      est <- MittagLeffleR::logMomentEstimator(WW)
      names(est) <-
        c("tail", "scale", "tailLo", "tailHi", "scaleLo", "scaleHi")
      c(k = k, est)
    })
  }

  plot_MLtail <- function(hline = NULL) {
    plot(
      MLestimates$k,
      MLestimates$tail,
      type = "l",
      ylab = "tail parameter",
      xlab = "exceedances",
      ylim = c(0, 1.5),
      main = "ML tail"
    )
    lines(MLestimates$k,
          MLestimates$tailHi,
          type = "l",
          col = "blue", lty = 2)
    lines(MLestimates$k,
          MLestimates$tailLo,
          type = "l",
          col = "blue", lty = 2)
    if (!is.null(hline))
      abline(h = hline, lty = 3, col=2)
  }

  plot_MLscale <- function(tail = NULL, hline = NULL) {
    # no rescaling if no tail parameter given
    if (is.null(tail))
      tail <- 1
    rescaledScale   <- MLestimates$scale   * MLestimates$k ^ (1 / tail)
    rescaledScaleLo <- MLestimates$scaleLo * MLestimates$k ^ (1 / tail)
    rescaledScaleHi <- MLestimates$scaleHi * MLestimates$k ^ (1 / tail)
    plot(
      MLestimates$k,
      rescaledScale,
      type = "l",
      ylab = "scale parameter",
      xlab = "exceedances",
      ylim = c(0, 2 * max(rescaledScale)),
      main = "ML scale"
    )
    lines(MLestimates$k,
          rescaledScaleLo,
          type = "l", col = "blue",
          lty = 2)
    lines(MLestimates$k,
          rescaledScaleHi,
          type = "l", col = "blue",
          lty = 2)
    if (!is.null(hline))
      abline(h = hline, lty = 3, col = 2)
  }

  plot_GPthreshold <- function(hline = NULL, ...) {
    POT::tcplot(JJ)
  }


  apply_threshold <- function(k = n) {
    if (k > n)
      stop("Can't threshold to ", k, " observations if I only have ", n)
    new_times       <- TT[idxJ[1:k]]
    new_magnitudes  <- JJ[idxJ[1:k]]
    new_mrp(data.frame(new_times, new_magnitudes))
  }

  plot_MLqq <- function(tail, k = n, log_scale = TRUE) {
    WW <- diff(sort(TT[idxJ[1:k]]))
    qqplot(
      WW,
      MittagLeffleR::qml(p = ppoints(k - 1), tail = tail),
      xlab = "Sample Quantiles",
      ylab = "Population Quantiles",
      main = "Mittag-Leffler QQ Plot",
      log = ifelse(log_scale, 'xy', '')
    )
  }

  cross_cor <- function(){
    ccf(diff(TT), JJ[-1], main = "CrossCor (Exc & Exc Time)")
  }

  hillPlot <- function(hline = NULL){
    fExtremes::hillPlot(diff(TT), main = "Hill Plot")
    if (!is.null(hline))
      abline(h = hline, lty = 3, col = 2)
  }

  getTimes <- function() {
    TT
  }

  getMags <- function() {
    JJ
  }

  empiCopula <- function(){
    WW <- diff(TT)
    n <- length(WW)
    x <- rank(diff(TT))/n
    y <- rank(JJ[-1])/n
    plot(x,y, main = "Emp. Copula (Exc & Exc Time)")
  }

  plot_diagnostics <- function(...){
    acf(diff(TT), main = "ACF (Exceedance Times)")
    acf(JJ, main = "ACF (Exceedances)")
    cross_cor()
    plot_MLqq(tail)
    empiCopula()
  }

  structure(f, class = 'mrp')
}
